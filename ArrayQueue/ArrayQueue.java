/**   A class that implements the ADT queue by using an expandable   circular array.   @author Frank M. Carrano   @author Timothy M. Henry   @author Joseph Erickson   @version 4.0 */public final class ArrayQueue<T> implements QueueInterface<T>{	// To Do: Declare instance variables	private T[] queue; //Circular array of queue entries and one unused location	private int frontIndex;	private int backIndex;	private boolean initialized = false;		private static final int DEFAULT_CAPACITY = 3; // Small capacity for testing	private static final int MAX_CAPACITY = 10000;	public ArrayQueue()	{		this(DEFAULT_CAPACITY);	} // end default constructor	public ArrayQueue(int initialCapacity)	{		// To Do:		@SuppressWarnings("unchecked")		T[] tempQueue = (T[]) new Object[initialCapacity+1];		queue = tempQueue;		frontIndex = 0;		backIndex = initialCapacity;		initialized = true;	} // end constructor	public void enqueue(T newEntry)	{		// To Do:		checkInitialization();		ensureCapacity();		backIndex = (backIndex + 1) % queue.length;		queue[backIndex] = newEntry;	} // end enqueue	public T getFront()	{		// To Do:		checkInitialization();				if(isEmpty()) {			throw new EmptyQueueException();		}		else {			return queue[frontIndex];		}	} // end getFront	public T dequeue()	{		// To Do:		checkInitialization();				if(isEmpty()) {			throw new EmptyQueueException();		}		else {			T front = queue[frontIndex];			queue[frontIndex] = null;			frontIndex = (frontIndex + 1) % queue.length;			return front;		}	} // end dequeue	public boolean isEmpty()	{		// To Do:		return frontIndex == ((backIndex + 1) % queue.length);	} // end isEmpty	public void clear()	{		// To Do:		checkInitialization();		if(!isEmpty()) {			for (int i = frontIndex; i != backIndex; i = (i + 1) % queue.length) {				queue[i] = null;			}			queue[backIndex] = null;		}		frontIndex = 0;		backIndex = queue.length-1;	} // end clear	// Throws an exception if this object is not initialized.	private void checkInitialization()	{		// To Do:		if(initialized == false) {			throw new IllegalStateException();		}	} // end checkInitialization	// Throws an exception if the client requests a capacity that is too large.	private void checkCapacity(int capacity)	{		// To Do:		if(capacity > MAX_CAPACITY) {			throw new IllegalArgumentException();		}	} // end checkCapacity	// Doubles the size of the array queue if it is full.	// Precondition: checkInitialization has been called.	private void ensureCapacity()	{		// To Do:		if(frontIndex == ((backIndex + 2) % queue.length)) { // if array is full, double size of array			T[] oldQueue = queue;			int oldSize = oldQueue.length;			int newSize = 2 * oldSize;						checkCapacity(newSize);			// The cast is safe because the new array contains null entries			@SuppressWarnings("unchecked")			T[] tempQueue = (T[]) new Object[newSize];			queue = tempQueue;			for (int index = 0; index < oldSize - 1; index ++) {				queue[index] = oldQueue[frontIndex];				frontIndex = (frontIndex + 1) % oldSize;			}						frontIndex = 0;			backIndex = oldSize - 2;		}	} // end ensureCapacity}  // end ArrayQueue